import numpy as np # для проверки
import random as rn 



def print_mas(MAS): # Функция выводит массив в виде матрицы
    for row in range(0, len(MAS)): # пробегаемся по строкам
        for col in range(0, len(MAS)): # пробегаемся по колонкам
            print(MAS[row][col], end=" ") # выводим на печать end - указываем " " (убираем перенос строки)
        print("") # переносим строку

def mB(A, k): # функция укорачивания массива
    B = [] # создаем пустой массив
    for row in range(1, len(A)): # пробегаемся по строкам массива начиная с 1 строки, а не с нулевой
        B.append([]) # добавляем пустой элемент строки в пустой массив
        for col in range(0, len(A)): # пробегаемся по строке row по столбцу
            if col != k: # этой проверкой ислючаем ненужный столбец
                B[row-1].append(A[row][col]) # после исключения ненужного столбца добавляем элемент в сохданный массив
    return B # возвращаем укороченный массив


def det(MAS): # функция вычисления определителя
    n = len(MAS) # передаем длину массива
    z = -1 
    deter = 0 
    if n == 1: # если массив из одного элемента, то выводи этот элемент
        return MAS[0][0] 
    else:
        for i in range(0, n): # пробегаемся циклом для определения количества укороченных массивов
            z = -z 
            deter += z * MAS[0][i] * det(mB(MAS, i)) # увеличиваем значение определителя, умножив необходимый элемент на результат функции, которую вызываем рекурсивно (при каждомзаходе в функцию мы вызываем функцию укорачивания массива)
        return deter

A = [] # Создаем пустой массив
N = 4 # вводим размерность массива

for row in range(0, N): # Заполняем массив размерностью N случайными вещественными числами
    A.append([])
    for col in range(0, N):
        A[row].append(rn.uniform(1, 10))


print_mas(A) # выводим на экран массив
print(det(A)) # выводим на экран определитель матрицы
print(np.linalg.det(A)) # Проверка